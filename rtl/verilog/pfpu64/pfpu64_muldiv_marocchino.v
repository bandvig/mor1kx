//////////////////////////////////////////////////////////////////////
//                                                                  //
//    pfpu64_muldiv_marocchino                                      //
//                                                                  //
//    This file is part of the mor1kx project                       //
//    https://github.com/openrisc/mor1kx                            //
//                                                                  //
//    Description                                                   //
//    combined multiplier/divisor pipeline for                      //
//    single precision floating point numbers                       //
//    for MAROCCHINO pipeline                                       //
//                                                                  //
//    Author(s):                                                    //
//          Andrey Bacherov, avbacherov@opencores.org               //
//                                                                  //
//////////////////////////////////////////////////////////////////////
//                                                                  //
//  Copyright (C) 2015 - 2016                                       //
//                                                                  //
//  This source file may be used and distributed without            //
//  restriction provided that this copyright statement is not       //
//  removed from the file and that any derivative work contains     //
//  the original copyright notice and the associated disclaimer.    //
//                                                                  //
//    THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY           //
//  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED       //
//  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS       //
//  FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR          //
//  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,             //
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES        //
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE       //
//  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR            //
//  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      //
//  LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT      //
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT      //
//  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             //
//  POSSIBILITY OF SUCH DAMAGE.                                     //
//////////////////////////////////////////////////////////////////////

`include "mor1kx-defines.v"

module pfpu64_muldiv_marocchino
(
  // clocks and resets
  input             clk,
  input             rst,
  // pipe controls
  input             pipeline_flush_i,   // flushe pipe
  input             is_mul_i,
  input             is_div_i,
  output            muldiv_taking_op_o,
  output            mul_rdy_o,          // multiplier ready
  input             rnd_taking_mul_i,
  output            div_rdy_o,          // divider ready
  input             rnd_taking_div_i,
  // input 'a' related values
  input             signa_i,
  input      [12:0] exp13a_i,
  input      [52:0] fract53a_i,
  input             infa_i,
  input             zeroa_i,
  // input 'b' related values
  input             signb_i,
  input      [12:0] exp13b_i,
  input      [52:0] fract53b_i,
  input             infb_i,
  input             zerob_i,
  // 'a'/'b' related
  input             snan_i,
  input             qnan_i,
  input             anan_sign_i,
  // MUL outputs
  output            mul_sign_o,      // signum
  output      [5:0] mul_shr_o,       // do right shift in align stage
  output     [12:0] mul_exp13shr_o,  // exponent for right shift align
  output     [12:0] mul_exp13sh0_o,  // exponent for no shift in align
  output     [56:0] mul_fract57_o,   // fractional with appended {r,s} bits
  output            mul_inv_o,       // invalid operation flag
  output            mul_inf_o,       // infinity output reg
  output            mul_snan_o,      // signaling NaN output reg
  output            mul_qnan_o,      // quiet NaN output reg
  output            mul_anan_sign_o, // signum for output nan
  // DIV outputs
  output            div_sign_o,      // signum
  output      [5:0] div_shr_o,       // do right shift in align stage
  output     [12:0] div_exp13shr_o,  // exponent for right shift align
  output            div_shl_o,       // do left shift in align stage
  output     [12:0] div_exp13shl_o,  // exponent for left shift align
  output     [12:0] div_exp13sh0_o,  // exponent for no shift in align
  output     [56:0] div_fract57_o,   // fractional with appended {r,s} bits
  output            div_dbz_o,       // div division by zero flag
  output            div_inv_o,       // invalid operation flag
  output            div_inf_o,       // infinity output reg
  output            div_snan_o,      // signaling NaN output reg
  output            div_qnan_o,      // quiet NaN output reg
  output            div_anan_sign_o  // signum for output nan
);

  /*
     Any stage's output is registered.
     Definitions:
       s??o_name - "S"tage number "??", "O"utput
       s??t_name - "S"tage number "??", "T"emporary (internally)
  */


  // MUL/DIV pipe controls
  //  ## ready flags
  reg s0o_mul_ready, s0o_div_ready;
  reg s1o_mul_ready, s1o_div_ready;
  //  ## Multiplier / Divider is taking operands
  wire mul_taking_op, mul_busy;
  wire div_taking_op, div_busy;
  //  ## per stage busy flags
  wire s1_busy = mul_busy | div_busy;
  wire s0_busy = (s0o_mul_ready | s0o_div_ready) & s1_busy;
  //  ## per stage advance flags
  wire s0_adv = (is_mul_i | is_div_i) & ~s0_busy;
  wire s1_adv = (s0o_mul_ready | s0o_div_ready) & ~s1_busy;
  wire s2_adv = mul_taking_op | div_taking_op;
  //  ## MUL/DIV taking operands
  assign muldiv_taking_op_o = s0_adv;


  /**** Stage #0: pre-normalization stage ****/


    // detection of some exceptions
  wire s0t_inv = (is_div_i & ((zeroa_i & zerob_i) | (infa_i & infb_i))) | // div: 0/0, inf/inf -> invalid operation; snan output
                 (is_mul_i & ((zeroa_i & infb_i) | (zerob_i & infa_i)));  // mul: 0 * inf -> invalid operation; snan output
    // inf input
  wire s0t_inf = infa_i | (infb_i & is_mul_i); // for DIV only infA is used

    // force intermediate results to zero
  wire s0t_opc_0 = zeroa_i | zerob_i | (is_div_i & (infa_i | infb_i));

  // count leading zeros
  reg [5:0] s0t_nlza;
  always @(fract53a_i) begin
    casez (fract53a_i) // synopsys full_case parallel_case
      53'b1????????????????????????????????????????????????????: s0t_nlza =  6'd0;
      53'b01???????????????????????????????????????????????????: s0t_nlza =  6'd1;
      53'b001??????????????????????????????????????????????????: s0t_nlza =  6'd2;
      53'b0001?????????????????????????????????????????????????: s0t_nlza =  6'd3;
      53'b00001????????????????????????????????????????????????: s0t_nlza =  6'd4;
      53'b000001???????????????????????????????????????????????: s0t_nlza =  6'd5;
      53'b0000001??????????????????????????????????????????????: s0t_nlza =  6'd6;
      53'b00000001?????????????????????????????????????????????: s0t_nlza =  6'd7;
      53'b000000001????????????????????????????????????????????: s0t_nlza =  6'd8;
      53'b0000000001???????????????????????????????????????????: s0t_nlza =  6'd9;
      53'b00000000001??????????????????????????????????????????: s0t_nlza = 6'd10;
      53'b000000000001?????????????????????????????????????????: s0t_nlza = 6'd11;
      53'b0000000000001????????????????????????????????????????: s0t_nlza = 6'd12;
      53'b00000000000001???????????????????????????????????????: s0t_nlza = 6'd13;
      53'b000000000000001??????????????????????????????????????: s0t_nlza = 6'd14;
      53'b0000000000000001?????????????????????????????????????: s0t_nlza = 6'd15;
      53'b00000000000000001????????????????????????????????????: s0t_nlza = 6'd16;
      53'b000000000000000001???????????????????????????????????: s0t_nlza = 6'd17;
      53'b0000000000000000001??????????????????????????????????: s0t_nlza = 6'd18;
      53'b00000000000000000001?????????????????????????????????: s0t_nlza = 6'd19;
      53'b000000000000000000001????????????????????????????????: s0t_nlza = 6'd20;
      53'b0000000000000000000001???????????????????????????????: s0t_nlza = 6'd21;
      53'b00000000000000000000001??????????????????????????????: s0t_nlza = 6'd22;
      53'b000000000000000000000001?????????????????????????????: s0t_nlza = 6'd23;
      53'b0000000000000000000000001????????????????????????????: s0t_nlza = 6'd24;
      53'b00000000000000000000000001???????????????????????????: s0t_nlza = 6'd25;
      53'b000000000000000000000000001??????????????????????????: s0t_nlza = 6'd26;
      53'b0000000000000000000000000001?????????????????????????: s0t_nlza = 6'd27;
      53'b00000000000000000000000000001????????????????????????: s0t_nlza = 6'd28;
      53'b000000000000000000000000000001???????????????????????: s0t_nlza = 6'd29;
      53'b0000000000000000000000000000001??????????????????????: s0t_nlza = 6'd30;
      53'b00000000000000000000000000000001?????????????????????: s0t_nlza = 6'd31;
      53'b000000000000000000000000000000001????????????????????: s0t_nlza = 6'd32;
      53'b0000000000000000000000000000000001???????????????????: s0t_nlza = 6'd33;
      53'b00000000000000000000000000000000001??????????????????: s0t_nlza = 6'd34;
      53'b000000000000000000000000000000000001?????????????????: s0t_nlza = 6'd35;
      53'b0000000000000000000000000000000000001????????????????: s0t_nlza = 6'd36;
      53'b00000000000000000000000000000000000001???????????????: s0t_nlza = 6'd37;
      53'b000000000000000000000000000000000000001??????????????: s0t_nlza = 6'd38;
      53'b0000000000000000000000000000000000000001?????????????: s0t_nlza = 6'd39;
      53'b00000000000000000000000000000000000000001????????????: s0t_nlza = 6'd40;
      53'b000000000000000000000000000000000000000001???????????: s0t_nlza = 6'd41;
      53'b0000000000000000000000000000000000000000001??????????: s0t_nlza = 6'd42;
      53'b00000000000000000000000000000000000000000001?????????: s0t_nlza = 6'd43;
      53'b000000000000000000000000000000000000000000001????????: s0t_nlza = 6'd44;
      53'b0000000000000000000000000000000000000000000001???????: s0t_nlza = 6'd45;
      53'b00000000000000000000000000000000000000000000001??????: s0t_nlza = 6'd46;
      53'b000000000000000000000000000000000000000000000001?????: s0t_nlza = 6'd47;
      53'b0000000000000000000000000000000000000000000000001????: s0t_nlza = 6'd48;
      53'b00000000000000000000000000000000000000000000000001???: s0t_nlza = 6'd49;
      53'b000000000000000000000000000000000000000000000000001??: s0t_nlza = 6'd50;
      53'b0000000000000000000000000000000000000000000000000001?: s0t_nlza = 6'd51;
      53'b00000000000000000000000000000000000000000000000000001: s0t_nlza = 6'd52;
      53'b00000000000000000000000000000000000000000000000000000: s0t_nlza =  6'd0; // zero rezult
    endcase
  end // nlz for 'a'

  // count leading zeros
  reg [5:0] s0t_nlzb;
  always @(fract53b_i) begin
    casez (fract53b_i) // synopsys full_case parallel_case
      53'b1????????????????????????????????????????????????????: s0t_nlzb =  6'd0;
      53'b01???????????????????????????????????????????????????: s0t_nlzb =  6'd1;
      53'b001??????????????????????????????????????????????????: s0t_nlzb =  6'd2;
      53'b0001?????????????????????????????????????????????????: s0t_nlzb =  6'd3;
      53'b00001????????????????????????????????????????????????: s0t_nlzb =  6'd4;
      53'b000001???????????????????????????????????????????????: s0t_nlzb =  6'd5;
      53'b0000001??????????????????????????????????????????????: s0t_nlzb =  6'd6;
      53'b00000001?????????????????????????????????????????????: s0t_nlzb =  6'd7;
      53'b000000001????????????????????????????????????????????: s0t_nlzb =  6'd8;
      53'b0000000001???????????????????????????????????????????: s0t_nlzb =  6'd9;
      53'b00000000001??????????????????????????????????????????: s0t_nlzb = 6'd10;
      53'b000000000001?????????????????????????????????????????: s0t_nlzb = 6'd11;
      53'b0000000000001????????????????????????????????????????: s0t_nlzb = 6'd12;
      53'b00000000000001???????????????????????????????????????: s0t_nlzb = 6'd13;
      53'b000000000000001??????????????????????????????????????: s0t_nlzb = 6'd14;
      53'b0000000000000001?????????????????????????????????????: s0t_nlzb = 6'd15;
      53'b00000000000000001????????????????????????????????????: s0t_nlzb = 6'd16;
      53'b000000000000000001???????????????????????????????????: s0t_nlzb = 6'd17;
      53'b0000000000000000001??????????????????????????????????: s0t_nlzb = 6'd18;
      53'b00000000000000000001?????????????????????????????????: s0t_nlzb = 6'd19;
      53'b000000000000000000001????????????????????????????????: s0t_nlzb = 6'd20;
      53'b0000000000000000000001???????????????????????????????: s0t_nlzb = 6'd21;
      53'b00000000000000000000001??????????????????????????????: s0t_nlzb = 6'd22;
      53'b000000000000000000000001?????????????????????????????: s0t_nlzb = 6'd23;
      53'b0000000000000000000000001????????????????????????????: s0t_nlzb = 6'd24;
      53'b00000000000000000000000001???????????????????????????: s0t_nlzb = 6'd25;
      53'b000000000000000000000000001??????????????????????????: s0t_nlzb = 6'd26;
      53'b0000000000000000000000000001?????????????????????????: s0t_nlzb = 6'd27;
      53'b00000000000000000000000000001????????????????????????: s0t_nlzb = 6'd28;
      53'b000000000000000000000000000001???????????????????????: s0t_nlzb = 6'd29;
      53'b0000000000000000000000000000001??????????????????????: s0t_nlzb = 6'd30;
      53'b00000000000000000000000000000001?????????????????????: s0t_nlzb = 6'd31;
      53'b000000000000000000000000000000001????????????????????: s0t_nlzb = 6'd32;
      53'b0000000000000000000000000000000001???????????????????: s0t_nlzb = 6'd33;
      53'b00000000000000000000000000000000001??????????????????: s0t_nlzb = 6'd34;
      53'b000000000000000000000000000000000001?????????????????: s0t_nlzb = 6'd35;
      53'b0000000000000000000000000000000000001????????????????: s0t_nlzb = 6'd36;
      53'b00000000000000000000000000000000000001???????????????: s0t_nlzb = 6'd37;
      53'b000000000000000000000000000000000000001??????????????: s0t_nlzb = 6'd38;
      53'b0000000000000000000000000000000000000001?????????????: s0t_nlzb = 6'd39;
      53'b00000000000000000000000000000000000000001????????????: s0t_nlzb = 6'd40;
      53'b000000000000000000000000000000000000000001???????????: s0t_nlzb = 6'd41;
      53'b0000000000000000000000000000000000000000001??????????: s0t_nlzb = 6'd42;
      53'b00000000000000000000000000000000000000000001?????????: s0t_nlzb = 6'd43;
      53'b000000000000000000000000000000000000000000001????????: s0t_nlzb = 6'd44;
      53'b0000000000000000000000000000000000000000000001???????: s0t_nlzb = 6'd45;
      53'b00000000000000000000000000000000000000000000001??????: s0t_nlzb = 6'd46;
      53'b000000000000000000000000000000000000000000000001?????: s0t_nlzb = 6'd47;
      53'b0000000000000000000000000000000000000000000000001????: s0t_nlzb = 6'd48;
      53'b00000000000000000000000000000000000000000000000001???: s0t_nlzb = 6'd49;
      53'b000000000000000000000000000000000000000000000000001??: s0t_nlzb = 6'd50;
      53'b0000000000000000000000000000000000000000000000000001?: s0t_nlzb = 6'd51;
      53'b00000000000000000000000000000000000000000000000000001: s0t_nlzb = 6'd52;
      53'b00000000000000000000000000000000000000000000000000000: s0t_nlzb =  6'd0; // zero rezult
    endcase
  end // nlz of 'b'

  // pre-norm stage outputs
  //   input related
  reg s0o_inv, s0o_inf,
      s0o_snan, s0o_qnan, s0o_anan_sign;
  //   computation related
  reg        s0o_opc_0;
  reg        s0o_signc;
  reg [12:0] s0o_exp13a;
  reg [52:0] s0o_fract53a;
  reg  [5:0] s0o_shla;
  reg [12:0] s0o_exp13b;
  reg [52:0] s0o_fract53b;
  reg  [5:0] s0o_shlb;
  // registering
  always @(posedge clk) begin
    if (s0_adv) begin
        // input related
      s0o_inv       <= s0t_inv;
      s0o_inf       <= s0t_inf;
      s0o_snan      <= snan_i;
      s0o_qnan      <= qnan_i;
      s0o_anan_sign <= anan_sign_i;
        // computation related
      s0o_opc_0     <= s0t_opc_0;
      s0o_signc     <= signa_i ^ signb_i;
      s0o_exp13a    <= exp13a_i;
      s0o_fract53a  <= fract53a_i;
      s0o_shla      <= s0t_nlza;
      s0o_exp13b    <= exp13b_i;
      s0o_fract53b  <= fract53b_i;
      s0o_shlb      <= s0t_nlzb;
    end // push pipe
  end

  // stage #0 is ready
  always @(posedge clk `OR_ASYNC_RST) begin
    if (rst) begin
      s0o_div_ready <= 1'b0;
      s0o_mul_ready <= 1'b0;
    end
    else if (pipeline_flush_i) begin
      s0o_div_ready <= 1'b0;
      s0o_mul_ready <= 1'b0;
    end
    else if (s0_adv) begin
      s0o_div_ready <= is_div_i;
      s0o_mul_ready <= is_mul_i;
    end
    else if (s1_adv) begin
      s0o_div_ready <= 1'b0;
      s0o_mul_ready <= 1'b0;
    end
  end // posedge clock


  /**** Stage #1: normalization stage ****/


  // left-shift the dividend and divisor
  wire [52:0] s1t_fract53a = s0o_fract53a << s0o_shla;
  wire [52:0] s1t_fract53b = s0o_fract53b << s0o_shlb;

  // exponent
  wire [12:0] s1t_exp13mux =
    ({13{s0o_div_ready}} & (s0o_exp13a - {7'd0,s0o_shla} - s0o_exp13b + {7'd0,s0o_shlb} + 13'd1023)) |
    ({13{s0o_mul_ready}} & (s0o_exp13a - {7'd0,s0o_shla} + s0o_exp13b - {7'd0,s0o_shlb} - 13'd1023));

  // force result to zero
  wire [12:0] s1t_exp13c = s1t_exp13mux & {13{~s0o_opc_0}};

  // stage #1 outputs
  //   input related
  reg s1o_inv, s1o_inf,
      s1o_snan, s1o_qnan, s1o_anan_sign;
  //   computation related
  reg        s1o_opc_0;
  reg        s1o_signc;
  reg [12:0] s1o_exp13c;
  reg [52:0] s1o_fract53a;
  reg [52:0] s1o_fract53b;
  //   registering
  always @(posedge clk) begin
    if (s1_adv) begin
        // input related
      s1o_inv       <= s0o_inv;
      s1o_inf       <= s0o_inf;
      s1o_snan      <= s0o_snan;
      s1o_qnan      <= s0o_qnan;
      s1o_anan_sign <= s0o_anan_sign;
        // computation related
      s1o_opc_0     <= s0o_opc_0;
      s1o_signc     <= s0o_signc;
      s1o_exp13c    <= s1t_exp13c;
      s1o_fract53a  <= s1t_fract53a;
      s1o_fract53b  <= s1t_fract53b;
    end // advance pipe
  end // posedge clock

  // ready for MUL instruction
  always @(posedge clk `OR_ASYNC_RST) begin
    if (rst) begin
      s1o_mul_ready <= 1'b0;
      s1o_div_ready <= 1'b0;
    end
    else if (pipeline_flush_i) begin
      s1o_mul_ready <= 1'b0;
      s1o_div_ready <= 1'b0;
    end
    else if (s1_adv) begin
      s1o_mul_ready <= s0o_mul_ready;
      s1o_div_ready <= s0o_div_ready;
    end
    else if (s2_adv) begin
      s1o_mul_ready <= 1'b0;
      s1o_div_ready <= 1'b0;
    end
  end // posedge clock


  /**** Run Multiplier or Divider ****/


  // right shift value
  // and appropriatelly corrected exponent
  wire s1o_exp13c_0              = ~(|s1o_exp13c);
  wire [12:0] s2t_shr_of_neg_exp = 14'h2001 - {1'b0,s1o_exp13c}; // 8192-v+1
  // variants:
  wire [12:0] s2t_shr_t;
  wire [12:0] s2t_exp13rx;
  assign {s2t_shr_t,s2t_exp13rx} =
    // force zero result
    s1o_opc_0     ? {13'd0,13'd0} :
    // negative exponent sum
    //   (!) takes 1x.xx case into account automatically
    s1o_exp13c[12] ? {s2t_shr_of_neg_exp,13'd1} :
    // (a) zero exponent sum (denorm. result potentially)
    //   (!) takes 1x.xx case into account automatically
    // (b) normal case
    //   (!) 1x.xx case is processed in next stage
                    {{12'd0,s1o_exp13c_0},(s1o_exp13c | {12'd0,s1o_exp13c_0})};
  // limited by 64 and forced result to zero
  wire [5:0] s2t_shrx = s2t_shr_t[5:0] | {6{|s2t_shr_t[12:6]}};


  /**** Multiplier instance ****/


  pfpu64_mul_marocchino u_fp64_mul
  (
    // clocks and resets
    .clk                (clk), // FP64_MUL
    .rst                (rst), // FP64_MUL
    // pipe controls
    .pipeline_flush_i   (pipeline_flush_i), // FP64_MUL
    .s1o_mul_ready_i    (s1o_mul_ready), // FP64_MUL
    .mul_busy_o         (mul_busy), // FP64_MUL
    .mul_taking_op_o    (mul_taking_op), // FP64_MUL
    .mul_rdy_o          (mul_rdy_o), // FP64_MUL
    .rnd_taking_mul_i   (rnd_taking_mul_i), // FP64_MUL
    // operands
    .s1o_signc_i        (s1o_signc), // FP64_MUL
    .s1o_exp13c_i       (s1o_exp13c), // FP64_MUL
    .s2t_shrx_i         (s2t_shrx), // FP64_MUL
    .s2t_exp13rx_i      (s2t_exp13rx), // FP64_MUL
    .s1o_fract53a_i     (s1o_fract53a), // FP64_MUL
    .s1o_fract53b_i     (s1o_fract53b), // FP64_MUL
    // 'a'/'b' related
    .s1o_inv_i          (s1o_inv), // FP64_MUL
    .s1o_inf_i          (s1o_inf), // FP64_MUL
    .s1o_snan_i         (s1o_snan), // FP64_MUL
    .s1o_qnan_i         (s1o_qnan), // FP64_MUL
    .s1o_anan_sign_i    (s1o_anan_sign), // FP64_MUL
    // MUL outputs
    .mul_sign_o         (mul_sign_o), // FP64_MUL
    .mul_shr_o          (mul_shr_o), // FP64_MUL
    .mul_exp13shr_o     (mul_exp13shr_o), // FP64_MUL
    .mul_exp13sh0_o     (mul_exp13sh0_o), // FP64_MUL
    .mul_fract57_o      (mul_fract57_o), // FP64_MUL
    .mul_inv_o          (mul_inv_o), // FP64_MUL
    .mul_inf_o          (mul_inf_o), // FP64_MUL
    .mul_snan_o         (mul_snan_o), // FP64_MUL
    .mul_qnan_o         (mul_qnan_o), // FP64_MUL
    .mul_anan_sign_o    (mul_anan_sign_o) // FP64_MUL
  );


  /**** Divider instance ****/


  pfpu64_div_marocchino u_fp64_div
  (
    // clocks and resets
    .clk                (clk), // FP64_DIV
    .rst                (rst), // FP64_DIV
    // pipe controls
    .pipeline_flush_i   (pipeline_flush_i), // FP64_DIV
    .s1o_div_ready_i    (s1o_div_ready), // FP64_DIV
    .div_busy_o         (div_busy), // FP64_DIV
    .div_taking_op_o    (div_taking_op), // FP64_DIV
    .div_rdy_o          (div_rdy_o), // FP64_DIV
    .rnd_taking_div_i   (rnd_taking_div_i), // FP64_DIV
    // operands
    .s1o_signc_i        (s1o_signc), // FP64_DIV
    .s1o_exp13c_i       (s1o_exp13c), // FP64_DIV
    .s2t_shrx_i         (s2t_shrx), // FP64_DIV
    .s2t_exp13rx_i      (s2t_exp13rx), // FP64_DIV
    .s1o_fract53a_i     (s1o_fract53a), // FP64_DIV
    .s1o_fract53b_i     (s1o_fract53b), // FP64_DIV
    .s1o_opc_0_i        (s1o_opc_0), // FP64_DIV
    // 'a'/'b' related
    .s1o_inv_i          (s1o_inv), // FP64_DIV
    .s1o_inf_i          (s1o_inf), // FP64_DIV
    .s1o_snan_i         (s1o_snan), // FP64_DIV
    .s1o_qnan_i         (s1o_qnan), // FP64_DIV
    .s1o_anan_sign_i    (s1o_anan_sign), // FP64_DIV
    // MUL outputs
    .div_sign_o         (div_sign_o), // FP64_DIV
    .div_shr_o          (div_shr_o), // FP64_DIV
    .div_exp13shr_o     (div_exp13shr_o), // FP64_DIV
    .div_shl_o          (div_shl_o), // FP64_DIV
    .div_exp13shl_o     (div_exp13shl_o), // FP64_DIV
    .div_exp13sh0_o     (div_exp13sh0_o), // FP64_DIV
    .div_fract57_o      (div_fract57_o), // FP64_DIV
    .div_dbz_o          (div_dbz_o), // FP64_DIV
    .div_inv_o          (div_inv_o), // FP64_DIV
    .div_inf_o          (div_inf_o), // FP64_DIV
    .div_snan_o         (div_snan_o), // FP64_DIV
    .div_qnan_o         (div_qnan_o), // FP64_DIV
    .div_anan_sign_o    (div_anan_sign_o) // FP64_DIV
  );

endmodule // pfpu64_muldiv_marocchino
